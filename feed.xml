<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:5000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:5000/" rel="alternate" type="text/html" /><updated>2019-07-12T14:31:16+02:00</updated><id>http://localhost:5000/feed.xml</id><title type="html">Meta-cedille blog</title><subtitle>A blog about metaprogramming and dependent type theory.</subtitle><entry><title type="html">Syntactic metaprogramming II</title><link href="http://localhost:5000/meta-cedille/2019/07/12/syntactic-metaprogramming-ii.html" rel="alternate" type="text/html" title="Syntactic metaprogramming II" /><published>2019-07-12T00:00:00+02:00</published><updated>2019-07-12T00:00:00+02:00</updated><id>http://localhost:5000/meta-cedille/2019/07/12/syntactic-metaprogramming-ii</id><content type="html" xml:base="http://localhost:5000/meta-cedille/2019/07/12/syntactic-metaprogramming-ii.html">&lt;p&gt;This is the second in a series of posts where I am going to explain how to use the metaprogramming features of &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille&quot;&gt;meta-cedille&lt;/a&gt;. If you haven’t read the &lt;a href=&quot;https://whatisrt.github.io/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html&quot;&gt;previous post&lt;/a&gt; this post might not make much sense.&lt;/p&gt;

&lt;p&gt;This time, I’ll be talking about a better function definition syntax, strings and parsing unrestricted grammars. The function definition syntax is an ML-like syntax. Let me give an example of what syntax we want to end up with:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b-let identity [X : *] (x : X) : X := x.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The main advantage of this notation is that we can get a type annotated definition without having to repeat types. The above example will de-sugar to:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let identity := Λ X : * λ x : X x : ∀ X : * Π x : X X.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So let’s discuss quickly how this works. After parsing the syntax, we will have access to a list of parameters (a parameter is a triple consisting of a flag deciding whether the parameter is supposed to be erased or not, a name and a type) and a type, in a addition to the name and the term representing the body. The list of parameters will then be converted to a stack of lambdas and a stack pis/foralls, which will be prepended to the body and the type respectively. So let’s implement it.&lt;/p&gt;

&lt;p&gt;First, I’ll use a better syntax for function application for better readability. It is implemented &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/BetterApp.mced&quot;&gt;here&lt;/a&gt;, and the syntax is &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[f x1 ... xn]&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;?xk&lt;/code&gt; refers to an erased application. In the original source this syntax isn’t used because the file that introduces it actually uses the better let definition, but we can do it here.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$param$_name__space_=colon=_space__term_ :=
  λ n : init$name λ _ : init$space λ _ : init$space λ t : init$term
    γ[mkPreParam n t].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the rule that parses the interior of parentheses, which should be quite straightforward. &lt;code class=&quot;highlighter-rouge&quot;&gt;mkPreParam&lt;/code&gt; is the constructor for a parameter without the information whether it is erased.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$params := [List Param].
let init$params$=lparen=_param_=rparen=_space__params_ :=
  λ p : PreParam λ _ : init$space γ[cons ?Param γ[mkParam false p]].
let init$params$=lsquare=_param_=rsquare=_space__params_ :=
  λ p : PreParam λ _ : init$space γ[cons ?Param γ[mkParam true p]].
let init$params$ := &amp;lt;nil Param&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These rules are for parsing a list of parameters. This should be straightforward as well: &lt;code class=&quot;highlighter-rouge&quot;&gt;mkParam&lt;/code&gt; is the constructor for a full parameter and in case we parsed it with surrounding parentheses, we pass &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;mkParam&lt;/code&gt; for an unerased parameter, and &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; for surrounding square brackets. To turn this list of parameters into the corresponding lambda abstractions, we use the following functions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let paramToLambda := λ t : init$term λ p : Param
  γ[γ[ifthenelse ?(Π _ : init$name Π _ : init$term Π _ : init$term init$term)
      [paramErased p]
      quote$Lambda
      quote$lambda]
    [paramName p] [paramType p] t]
  : Π _ : init$term Π _ : Param init$term.

let foldWithLambdas :=
  γ[foldl ?Param ?init$term paramToLambda]
  : Π _ : init$params Π _ : init$term init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$lambda&lt;/code&gt; (and all other such abstractions) is &lt;code class=&quot;highlighter-rouge&quot;&gt;Π _ : init$name Π _ : init$term Π _ : init$term init$term&lt;/code&gt;. After filling in a parameter, the type would be &lt;code class=&quot;highlighter-rouge&quot;&gt;Π _ : init$term init$term&lt;/code&gt;, so we want a function &lt;code class=&quot;highlighter-rouge&quot;&gt;Π _ : Param Π _ : init$term init$term&lt;/code&gt;. So this is what &lt;code class=&quot;highlighter-rouge&quot;&gt;paramToLambda&lt;/code&gt; does, except that the order of arguments is swapped. &lt;code class=&quot;highlighter-rouge&quot;&gt;paramErased&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;paramName&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;paramType&lt;/code&gt; are the three projections of the parameter, so &lt;code class=&quot;highlighter-rouge&quot;&gt;paramToLambda&lt;/code&gt; applies &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$lambda&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$Lambda&lt;/code&gt; (depending on the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;[paramErased p]&lt;/code&gt;) to &lt;code class=&quot;highlighter-rouge&quot;&gt;[paramName p]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;[paramType p]&lt;/code&gt;. Then, &lt;code class=&quot;highlighter-rouge&quot;&gt;foldWithLambdas&lt;/code&gt; applies this function recursively to the list of parameters. The function &lt;code class=&quot;highlighter-rouge&quot;&gt;foldWithPi&lt;/code&gt; is defined exactly the same, except that it uses &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$forall&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$Pi&lt;/code&gt;. Finally, the last parsing rule is defined as (sorry for the long name):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$stmt$b=minus=let_space__name__space__params_=colon=_space__term__space_=colon==equal=_space'__term_=dot= :=
  λ _ : init$space λ n : init$name λ _ : init$space
  λ params : init$params λ _ : init$space λ type : init$term
  λ _ : init$space λ _ : init$space' λ term : init$term
    γ[quote$annotatedLet n
      γ[foldWithLambdas params term]
      γ[foldWithPi params type]].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that this is a parsing rule for &lt;code class=&quot;highlighter-rouge&quot;&gt;stmt&lt;/code&gt;, so this is an example of how to define a new top-level statement. The function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$annotatedLet&lt;/code&gt; takes three arguments, &lt;code class=&quot;highlighter-rouge&quot;&gt;n, t&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;t'&lt;/code&gt;, and returns the quoted statement &lt;code class=&quot;highlighter-rouge&quot;&gt;let n := t : t'.&lt;/code&gt;. After setting the evaluator, we can run the above example and see it in action. It would of course be nice to improve this syntax a little bit, by allowing to bind multiple names to a type in one go (as in &lt;code class=&quot;highlighter-rouge&quot;&gt;(a b : T)&lt;/code&gt;). PR’s for this are welcome.&lt;/p&gt;

&lt;p&gt;Let’s continue with strings. Strings are of course encased in double quotes:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$term$=doublequote=_newstring_=doublequote= :=
  quote$String : Π _ : init$string init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We will get to the function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$String&lt;/code&gt; later. The interior of the double quotes is either empty or a character followed by the same nonterminal:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$newstring$ := init$string$nil : init$string.
let init$newstring$_stringchar__newstring_ :=
  init$string$cons : Π _ : init$char Π _ : init$string init$string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So what remains is to parse an (almost) arbitrary single character, which is done by the following syntax:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$stringchar$!=doublequote=! := λ c : init$char c.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The exclamation points encase a list of rules that match a single character, and negate these rules. After parsing the character, it is passed to the function. In this case, it matches every character except a double quote. So, after parsing a string, we get a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$string&lt;/code&gt;, which is essentially a list of &lt;code class=&quot;highlighter-rouge&quot;&gt;init$char&lt;/code&gt;’s, and we have to transform into a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$term&lt;/code&gt;, which is where the above mentioned &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$String&lt;/code&gt; function comes into play. It is defined as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b-let quote$String (s : init$string) : init$term :=
  γ[s ?init$term
      λ c : init$char λ rec : init$term
        γ[quote$square γ[quote$square quote$stringCons [quote$char c]] rec]
      quote$stringNil].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$string&lt;/code&gt; is defined with a Church encoding, so their elements are functions that pattern match on themselves. This can be seen in the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[s init$term]&lt;/code&gt;, which, after applying some syntactic sugar is:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(init$char -&amp;gt; init$term -&amp;gt; init$term) -&amp;gt; init$term -&amp;gt; init$term
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This means, if &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; is the empty string, &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[s ?init$term f n]&lt;/code&gt; evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, and if &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;s'&lt;/code&gt;, it evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[f c γ[s' ?init$term f n]]&lt;/code&gt;. Thus, in the case of &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$String&lt;/code&gt;, if we give the empty string to it, it evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$stringNil&lt;/code&gt; and if it is of the form &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;, it evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[quote$square γ[quote$square quote$stringCons [quote$char c]] [quote$String s]]&lt;/code&gt; which represents &lt;code class=&quot;highlighter-rouge&quot;&gt;[[stringCons c] s]&lt;/code&gt;. The definitions of &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$stringNil&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$stringCons&lt;/code&gt; are quite tedious and not repeated here.&lt;/p&gt;

&lt;p&gt;Note that this definition for a string syntax does not feature an escaping mechanism to let the double quote be typed within a string. This has been done mostly for the simplicity of the implementation and is left as an exercise to the reader (PR’s welcome). To parse everything except for a double quote and a backslash character, use &lt;code class=&quot;highlighter-rouge&quot;&gt;!=doublequote=&amp;amp;=backslash=!&lt;/code&gt;. A syntax for a single character would also be nice (parsing single quotes is done with just a &lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt; character instead of the escape mechanism).&lt;/p&gt;

&lt;p&gt;So now it should be somewhat clear how to define new notations that extend existing syntax. Defining a syntax for lists is not too difficult (see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/ListNotation.mced&quot;&gt;here&lt;/a&gt;), while defining a notation for inductive datatypes is probably challenging but given a good understanding of cedille it should still be mostly straightforward.&lt;/p&gt;

&lt;p&gt;For the remainder of this post, I want to discuss how to modify the evaluator of the language which is a very powerful feature that can be used to run arbitrary code after the parsing step.&lt;/p&gt;

&lt;p&gt;First, I want to give a brief introduction into the idea of the evaluator. In the previous examples, the result of parsing always had to result in something that is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt;, which is essentially a built-in type. One of the goals of this system was that everything should be modifiable by the user, so this type should not be fixed. To do this, we should be able to replace it with another type, say &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, such that elements of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; can be turned into executions of the systems. This is done with the meta monad, denoted by &lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;, which is a monad that can run executions in the environment. It has the monadic operations &lt;code class=&quot;highlighter-rouge&quot;&gt;ε&lt;/code&gt; (return/pure) and &lt;code class=&quot;highlighter-rouge&quot;&gt;μ&lt;/code&gt; (bind) as well as an operation &lt;code class=&quot;highlighter-rouge&quot;&gt;ξ&lt;/code&gt; that executes statements (of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt;) and returns something of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$metaResult&lt;/code&gt; (which is a type that captures errors and other things that the executions of statements might return), so if &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ξ t&lt;/code&gt; is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;ω init$metaResult&lt;/code&gt;. So, a function &lt;code class=&quot;highlighter-rouge&quot;&gt;f : A -&amp;gt; ω B&lt;/code&gt; is a function that can execute statements based on its input and return some value of type &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, and such a function can be registered as the evaluator with the &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; statement. Then, if the parsing step returns some term &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; of type &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, the environment will execute the value &lt;code class=&quot;highlighter-rouge&quot;&gt;[f t]&lt;/code&gt;. Note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; statement does not in any way change any previous definition. It just changes the evaluator that is used to evaluate statements. It is not possible to use the pointer to the current evaluator in a definition.&lt;/p&gt;

&lt;p&gt;The function that has been used as the evaluator up to this point is defined as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; let eval := λ s : init$stmt ξ s.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To show off what is possible by changing the evaluator, I will demonstrate how to work around the limitations of the parser, to parse a language that is not context-free. This is just a toy example, but it generalizes to parsing arbitrary languages. The language we want to parse is the language of all strings consisting of the letters &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, such that all letters appear equally often. This language is known to be context-sensitive, so in particular not a &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar that the parser can handle. To do this, we use a variation of the parsing rules for strings:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let csgdemo$char$a := quote$a : init$char.
let csgdemo$char$b := quote$b : init$char.
let csgdemo$char$c := quote$c : init$char.

let csgdemo$str := [List init$char].
let csgdemo$str$_char__str_ := &amp;lt;cons init$char&amp;gt;.
let csgdemo$str$ := &amp;lt;nil init$char&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; is a nonterminal that parses only strings of the letters &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; and returns that data as a string. Next, we define the evaluator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b-let csgdemoeval (l : [List init$char]) : ω Nat :=
  γ[ifthenelse ?(ω Nat) [abcEqual l]
    ε γ[countOccurencesChar quote$a l]
    μ [eval triggerError] λ _ : init$metaResult ε zero].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Just to make it clear how &lt;code class=&quot;highlighter-rouge&quot;&gt;ε&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;μ&lt;/code&gt; work, in a Haskell-like syntax this would read:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;csgdemoeval l =
  if abcEqual l
    then return (countOccurencesChar quote$a l)
    else (eval triggerError) &amp;gt;&amp;gt; return zero
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function &lt;code class=&quot;highlighter-rouge&quot;&gt;abcEqual&lt;/code&gt; takes a string and returns &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; iff the characters &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; appear equally as often. &lt;code class=&quot;highlighter-rouge&quot;&gt;countOccurencesChar&lt;/code&gt; takes a character and a string, and returns how often that character appears in that string. &lt;code class=&quot;highlighter-rouge&quot;&gt;triggerError&lt;/code&gt; is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt; and always triggers an error when executed (it represents &lt;code class=&quot;highlighter-rouge&quot;&gt;let dummy := dummy.&lt;/code&gt;, which will either complain that the name &lt;code class=&quot;highlighter-rouge&quot;&gt;dummy&lt;/code&gt; is undefined, or that the name &lt;code class=&quot;highlighter-rouge&quot;&gt;dummy&lt;/code&gt; is defined). So, &lt;code class=&quot;highlighter-rouge&quot;&gt;csgdemoeval&lt;/code&gt; will take the string, and if it has an equal count of the letters it will do nothing and return how often each letter appeared. Otherwise, it will trigger an error and return the number &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; afterwards. Finally, we set the evaluator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;seteval csgdemoeval csgdemo str.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This uses &lt;code class=&quot;highlighter-rouge&quot;&gt;csgdemoeval&lt;/code&gt; as the evaluator, &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; as the starting nonterminal and &lt;code class=&quot;highlighter-rouge&quot;&gt;csgdemo&lt;/code&gt; as the namespace.&lt;/p&gt;

&lt;p&gt;This is a very simple example of course, but it shows that it is possible to run arbitrary code to accept or reject parse results. This means that one could write a parser library that can handle stronger grammars than the built-in parser and use that library to write parsing rules. At the same time, this demonstrates how previous definitions can be hidden: after the &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; statement, there is no way to execute another &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; command, so it is impossible to go back.&lt;/p&gt;</content><author><name></name></author><summary type="html">This is the second in a series of posts where I am going to explain how to use the metaprogramming features of meta-cedille. If you haven’t read the previous post this post might not make much sense.</summary></entry><entry><title type="html">Syntactic metaprogramming I</title><link href="http://localhost:5000/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html" rel="alternate" type="text/html" title="Syntactic metaprogramming I" /><published>2019-06-25T00:00:00+02:00</published><updated>2019-06-25T00:00:00+02:00</updated><id>http://localhost:5000/meta-cedille/2019/06/25/syntactic-metaprogramming-i</id><content type="html" xml:base="http://localhost:5000/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html">&lt;p&gt;This is the first in a series of posts where I am going to explain how to use the metaprogramming features of &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille&quot;&gt;meta-cedille&lt;/a&gt;. Before we start discussing any specifics, I want to give a little background on the system. Meta-cedille is of course based on &lt;a href=&quot;https://github.com/cedille/cedille&quot;&gt;cedille&lt;/a&gt;, a minimalistic, dependently typed programming language without a datatype system. I won’t explain why cedille is an interesting theory here, but you can for example read this &lt;a href=&quot;https://medium.com/@maiavictor/towards-a-simple-theorem-prover-5005a1e66a6f&quot;&gt;post&lt;/a&gt; by Victor Maia, or have a look at the &lt;a href=&quot;https://cedille.github.io/docs/about.html#about&quot;&gt;cedille documentation&lt;/a&gt;. The main reason why cedille was chosen as a host language for this metaprogramming system was because of its simple implementation and consistency proof, but this is not its only advantage over other type theories.&lt;/p&gt;

&lt;p&gt;Meta-cedille is an extension of cedille (technically, &lt;a href=&quot;https://github.com/astump/cedille-core-spec/blob/master/spec.pdf&quot;&gt;cedille-core&lt;/a&gt;, implemented &lt;a href=&quot;https://github.com/cedille/cedille/tree/master/core&quot;&gt;here&lt;/a&gt;), that adds full syntactic metaprogramming without breaking the consistency of the underlying type theory. This means that not only terms or other code can be read and written within the language itself, but also the syntax of the language can be fully modified by the programmer. A user of the language can specify their own &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar (a special type of context-free grammar, with the restriction that any non-terminal can uniquely be assigned a parsing rule by just reading one character), that is to be used for parsing. This feature seems to have lots of potential as a substitute for built-in features, as well as for enabling features that other languages miss. For a somewhat complete list of what I believe to be possible, see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Things-(potentially)-enabled-by-this-kind-of-metaprogramming&quot;&gt;here&lt;/a&gt;. In particular, it seems possible to implement a syntactic sugar for inductive datatypes, which is something that Victor Maia talks about in the above mentioned post. His issue with cedille-core is that defining an inductive datatype requires a lot of boilerplate code, making it difficult to read and write. Further, if a syntactic sugar for inductive datatypes was added, it would either be part of the language implementation, making it more complicated (and adding potential for breaking something), or be something that would be expanded to regular cedille-core code before distribution, making it difficult to read. With meta-cedille, a third option seems possible: adding the syntactic sugar with metaprogramming, combining the advantages of both previously mentioned approaches.&lt;/p&gt;

&lt;p&gt;In this first entry, we will talk about how to add a notation for natural numbers to the language. Having the ability to do this was one of the initial design goals of the language. In fact, I found it always annoying that languages like Coq or Agda didn’t have a built-in data type for natural numbers, but that they had a syntax for writing their elements built-in. Thus, the &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Terms&quot;&gt;initial syntax&lt;/a&gt; of the language consists just of the terms of cedille-core, plus some necessary extensions for metaprogramming. This syntax was built with a goal of a simple implementation, so it is very bare-bones and sometimes hard to read. But the whole point of the language is that this doesn’t matter, as everything can be changed.&lt;/p&gt;

&lt;p&gt;This will mostly be an introduction by example. If you want a full explanation of how to modify the grammar of the language, see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Grammar&quot;&gt;here&lt;/a&gt;. You should have some familiarity with how parsing with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free grammar&lt;/a&gt; works.&lt;/p&gt;

&lt;p&gt;Let’s get started with the parsing rules. For simplicity, we’ll only do notation in base 2, but this will of course easily generalize:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$bindigit$0 := f : Bool.
let init$bindigit$1 := t : Bool.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that these are definitions of values of type &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt;. These two lines just define alternative names for the two inhabitants of the type. The type annotation on the right is always optional, but it gives a good additional safety check that we really have defined the right thing (it can also be used to replace an inferred type by a nicer, equivalent type). The important part happens to the left of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; sign: the names of values &lt;em&gt;may&lt;/em&gt; be used for parsing rules. Parsing rules consist of three parts, separated by &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; characters: first, a &lt;em&gt;prefix&lt;/em&gt; (or namespace, whatever you prefer), second a &lt;em&gt;nonterminal symbol&lt;/em&gt;, and third a &lt;em&gt;replacement&lt;/em&gt;. The prefix is later passed to a special command that applies the changes to the grammar, and all rules with that prefix will be considered. As we want to extend the previous grammar, we have to use the prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;. The nonterminal and replacements are fairly simple: we introduce two rules for a nonterminal &lt;code class=&quot;highlighter-rouge&quot;&gt;bindigit&lt;/code&gt; (that didn’t exist before), and it can be parsed either as &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or as &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. Depending on which digit was parsed, this will then either return the term &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;. Next:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$binnat'$_bindigit__binnat'_ :=
    &amp;lt;cons Bool&amp;gt; : Π _ : Bool Π _ : [List Bool] [List Bool].
    -- with better syntax, this would be Bool -&amp;gt; List Bool -&amp;gt; List Bool
let init$binnat'$ := &amp;lt;nil Bool&amp;gt; : [List Bool].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here, we’re defining a nonterminal &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt;, that can either be parsed by first parsing a &lt;code class=&quot;highlighter-rouge&quot;&gt;bindigit&lt;/code&gt; and then another &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt; (i.e. a digit and then possibly some more digits), or by parsing an empty string. Note that the square brackets denote the application of a term to a term, and the angle brackets denote erased application of terms (so if you would write &lt;code class=&quot;highlighter-rouge&quot;&gt;f x y&lt;/code&gt; in Haskell, you would have to write &lt;code class=&quot;highlighter-rouge&quot;&gt;[[f x] y]&lt;/code&gt; here). If you don’t know cedille, you can just regard the two forms of application as the same thing for now. This syntax is currently being used because it gives a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar, but I hope to migrate to a better syntax soon.&lt;/p&gt;

&lt;p&gt;In this piece of code, you can also see how the parsed data is collected: parsing a &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt; will give us a list of booleans. You can also see that the parsing rules essentially dictate the type of their values (this isn’t enforced: you can put arbitrary code on the right hand side. But you will get type errors after the parsing step if you don’t assign your types consistently). If you were wondering why the nonterminal was called &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt;, here is the reason:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$binnat$_bindigit__binnat'_ :=
    &amp;lt;cons Bool&amp;gt; : Π _ : Bool Π _ : [List Bool] [List Bool].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat&lt;/code&gt; should at least contain one digit, so we added an intermediate symbol to ensure this. The final parsing rule is this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$term$=nu=_binnat_ :=
    λ bs : [List Bool] [[quote$square quoteBoolListToNat] [quoteListBool bs]]
    : Π _ : [List Bool] init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So, we can parse a &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt;, by parsing &lt;code class=&quot;highlighter-rouge&quot;&gt;=nu=&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat&lt;/code&gt; afterwards. &lt;code class=&quot;highlighter-rouge&quot;&gt;=nu=&lt;/code&gt; is an escape code for the greek character ν. If you are wondering how to write parsing rules that use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$, _&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; characters, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;=dollar=, =underscore=&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;=equals=&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;The reason why we prefix a number with this character is because meta-cedille currently has support for de-Bruijn indices, which are indicated by unprefixed numbers. This will probably be changed in some form later, but for now, we have to put up with another prefix. The more interesting part in this definition is the part to the right of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; sign. First, note that the type shows us that this should be a function that takes a list of booleans and returns a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$term&lt;/code&gt;. This is just the type of terms - it contains only a single &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; character, so this isn’t used as a parsing rule. It was just convenient to name it like this, because all its constructors are parsing rules.&lt;/p&gt;

&lt;p&gt;The more interesting part in this rule is how it is defined. First, the function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$square&lt;/code&gt; (again, not a parsing rule) represents a term constructor that applies the second term to the first one, with square brackets. Thus, if &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; are terms, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[quote$square a] b]&lt;/code&gt; represents the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[a b]&lt;/code&gt;. The term &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteBoolListToNat&lt;/code&gt; is a reference to the function &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;[[quote$square quoteBoolListToNat] x]&lt;/code&gt; represents the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[boolListToNat x]&lt;/code&gt;. Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteListBool&lt;/code&gt; is a function that turns a list of booleans into a term by recursively writing down the constructors of that list and applying them properly. So, what this function will do at the end is take the list of bools you provided and replace it by a function application of &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt; to whatever list you provided. The implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt; is more or less standard, so I’m not going to talk about it here. &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteListBool&lt;/code&gt; is implemented as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let quoteListBool :=
    [[&amp;lt;&amp;lt;inductionList Bool&amp;gt; λ _ : [List Bool] init$term&amp;gt; quoteNilBool]
      λ b : Bool λ bs : [List Bool] λ rec : init$term
        [[quote$square [[quote$square quoteConsBool] [quoteBoolFun b]]] rec]]
    : Π _ : [List Bool] init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This needs some more explanation: &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;inductionList Bool&amp;gt; λ _ : [List Bool] init$term&amp;gt;&lt;/code&gt; is a function that takes as arguments a base case for induction and an inductive step and returns a function that turns a list of bools into a term. In case the list is the empty list we want to write &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;nil Bool&amp;gt;&lt;/code&gt;, which is what the term &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteNilBool&lt;/code&gt; does. In the inductive step the list consists of a first element and a rest, bound as &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt; respectively. We also get a term &lt;code class=&quot;highlighter-rouge&quot;&gt;rec&lt;/code&gt;, which is essentially the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[quoteListBool bs]&lt;/code&gt; (but we cannot write this here: we cannot refer to a name in its own definition). We want to write &lt;code class=&quot;highlighter-rouge&quot;&gt;[[&amp;lt;cons Bool&amp;gt; b] bs]&lt;/code&gt; here, which is precisely what the term after the lambdas does.&lt;/p&gt;

&lt;p&gt;If you are wondering why I used this function and a quoted list of bools instead of just writing &lt;code class=&quot;highlighter-rouge&quot;&gt;[suc [suc ... [suc zero] ... ]]&lt;/code&gt;, this has been done for performance reasons. The generated code needs to be typechecked afterwards and writing it down in unary notation would give us exponential typechecking time in the length of the number, whereas this solution is linear. The current environment meta-cedille runs in is already incredibly slow, and having the number 1000 need 10 minutes of typechecking is just bad.&lt;/p&gt;

&lt;p&gt;After all these definitions are finished, we can apply them:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;seteval eval init stmt.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second argument to &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; tells the environment to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; prefix, which then adds our new parsing rules to the already existing ones. The third argument specifies the initial nonterminal symbol to be used by the grammar (which is something we didn’t interact with so far - we could add a new top-level statement to the language by adding a parsing rule for &lt;code class=&quot;highlighter-rouge&quot;&gt;stmt&lt;/code&gt;). The first argument specifies the evaluator, which is used to execute the parsed data and potentially modify the environment. This is just a regular function with a special result type that can be defined by the user. I will write about these in future posts.&lt;/p&gt;

&lt;p&gt;You can find the full source code &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/NatSyntax.mced&quot;&gt;here&lt;/a&gt;, but to run it, you will need to import some other files beforehand (there is no module system yet and redundant imports will throw errors and abort execution, as of now). You can have a look at &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/NatSyntaxTest.mced&quot;&gt;this file&lt;/a&gt; which imports all the necessary files.&lt;/p&gt;</content><author><name></name></author><summary type="html">This is the first in a series of posts where I am going to explain how to use the metaprogramming features of meta-cedille. Before we start discussing any specifics, I want to give a little background on the system. Meta-cedille is of course based on cedille, a minimalistic, dependently typed programming language without a datatype system. I won’t explain why cedille is an interesting theory here, but you can for example read this post by Victor Maia, or have a look at the cedille documentation. The main reason why cedille was chosen as a host language for this metaprogramming system was because of its simple implementation and consistency proof, but this is not its only advantage over other type theories.</summary></entry></feed>