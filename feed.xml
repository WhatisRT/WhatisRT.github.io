<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:5000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:5000/" rel="alternate" type="text/html" /><updated>2019-06-25T16:25:55+02:00</updated><id>http://localhost:5000/feed.xml</id><title type="html">Meta-cedille blog</title><subtitle>A blog about metaprogramming and dependent type theory.</subtitle><entry><title type="html">Syntactic metaprogramming I</title><link href="http://localhost:5000/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html" rel="alternate" type="text/html" title="Syntactic metaprogramming I" /><published>2019-06-25T00:00:00+02:00</published><updated>2019-06-25T00:00:00+02:00</updated><id>http://localhost:5000/meta-cedille/2019/06/25/syntactic-metaprogramming-i</id><content type="html" xml:base="http://localhost:5000/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html">&lt;p&gt;This is the first in a series of posts where I am going to explain how to use the metaprogramming features of &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille&quot;&gt;meta-cedille&lt;/a&gt;. Before we start discussing any specifics, I want to give a little background on the system. Meta-cedille is of course based on &lt;a href=&quot;https://github.com/cedille/cedille&quot;&gt;cedille&lt;/a&gt;, a minimalistic, dependently typed programming language without a datatype system. I won’t explain why cedille is an interesting theory here, but you can for example read this &lt;a href=&quot;https://medium.com/@maiavictor/towards-a-simple-theorem-prover-5005a1e66a6f&quot;&gt;post&lt;/a&gt; by Victor Maia, or have a look at the &lt;a href=&quot;https://cedille.github.io/docs/about.html#about&quot;&gt;cedille documentation&lt;/a&gt;. The main reason why cedille was chosen as a host language for this metaprogramming system was because of its simple implementation and consistency proof, but this is not its only advantage over other type theories.&lt;/p&gt;

&lt;p&gt;Meta-cedille is an extension of cedille (technically, &lt;a href=&quot;https://github.com/astump/cedille-core-spec/blob/master/spec.pdf&quot;&gt;cedille-core&lt;/a&gt;, implemented &lt;a href=&quot;https://github.com/cedille/cedille/tree/master/core&quot;&gt;here&lt;/a&gt;), that adds full syntactic metaprogramming without breaking the consistency of the underlying type theory. This means that not only terms or other code can be read and written within the language itself, but also the syntax of the language can be fully modified by the programmer. A user of the language can specify their own &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar (a special type of context-free grammar, with the restriction that any non-terminal can uniquely be assigned a parsing rule by just reading one character), that is to be used for parsing. This feature seems to have lots of potential as a substitute for built-in features, as well as for enabling features that other languages miss. For a somewhat complete list of what I believe to be possible, see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Things-(potentially)-enabled-by-this-kind-of-metaprogramming&quot;&gt;here&lt;/a&gt;. In particular, it seems possible to implement a syntactic sugar for inductive datatypes, which is something that Victor Maia talks about in the above mentioned post. His issue with cedille-core is that defining an inductive datatype requires a lot of boilerplate code, making it difficult to read and write. Further, if a syntactic sugar for inductive datatypes was added, it would either be part of the language implementation, making it more complicated (and adding potential for breaking something), or be something that would be expanded to regular cedille-core code before distribution, making it difficult to read. With meta-cedille, a third option seems possible: adding the syntactic sugar with metaprogramming, combining the advantages of both previously mentioned approaches.&lt;/p&gt;

&lt;p&gt;In this first entry, we will talk about how to add a notation for natural numbers to the language. Having the ability to do this was one of the initial design goals of the language. In fact, I found it always annoying that languages like Coq or Agda didn’t have a built-in data type for natural numbers, but that they had a syntax for writing their elements built-in. Thus, the &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Terms&quot;&gt;initial syntax&lt;/a&gt; of the language consists just of the terms of cedille-core, plus some necessary extensions for metaprogramming. This syntax was built with a goal of a simple implementation, so it is very bare-bones and sometimes hard to read. But the whole point of the language is that this doesn’t matter, as everything can be changed.&lt;/p&gt;

&lt;p&gt;This will mostly be an introduction by example. If you want a full explanation of how to modify the grammar of the language, see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Grammar&quot;&gt;here&lt;/a&gt;. You should have some familiarity with how parsing with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free grammar&lt;/a&gt; works.&lt;/p&gt;

&lt;p&gt;Let’s get started with the parsing rules. For simplicity, we’ll only do notation in base 2, but this will of course easily generalize:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$bindigit$0 := f : Bool.
let init$bindigit$1 := t : Bool.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that these are definitions of values of type &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt;. These two lines just define alternative names for the two inhabitants of the type. The type annotation on the right is always optional, but it gives a good additional safety check that we really have defined the right thing (it can also be used to replace an inferred type by a nicer, equivalent type). The important part happens to the left of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; sign: the names of values &lt;em&gt;may&lt;/em&gt; be used for parsing rules. Parsing rules consist of three parts, separated by &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; characters: first, a &lt;em&gt;prefix&lt;/em&gt; (or namespace, whatever you prefer), second a &lt;em&gt;nonterminal symbol&lt;/em&gt;, and third a &lt;em&gt;replacement&lt;/em&gt;. The prefix is later passed to a special command that applies the changes to the grammar, and all rules with that prefix will be considered. As we want to extend the previous grammar, we have to use the prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;. The nonterminal and replacements are fairly simple: we introduce two rules for a nonterminal &lt;code class=&quot;highlighter-rouge&quot;&gt;bindigit&lt;/code&gt; (that didn’t exist before), and it can be parsed either as &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or as &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. Depending on which digit was parsed, this will then either return the term &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;. Next:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$binnat'$_bindigit__binnat'_ :=
    &amp;lt;cons Bool&amp;gt; : Π _ : Bool Π _ : [List Bool] [List Bool].
    -- with better syntax, this would be Bool -&amp;gt; List Bool -&amp;gt; List Bool
let init$binnat'$ := &amp;lt;nil Bool&amp;gt; : [List Bool].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here, we’re defining a nonterminal &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt;, that can either be parsed by first parsing a &lt;code class=&quot;highlighter-rouge&quot;&gt;bindigit&lt;/code&gt; and then another &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt; (i.e. a digit and then possibly some more digits), or by parsing an empty string. Note that the square brackets denote the application of a term to a term, and the angle brackets denote erased application of terms (so if you would write &lt;code class=&quot;highlighter-rouge&quot;&gt;f x y&lt;/code&gt; in Haskell, you would have to write &lt;code class=&quot;highlighter-rouge&quot;&gt;[[f x] y]&lt;/code&gt; here). If you don’t know cedille, you can just regard the two forms of application as the same thing for now. This syntax is currently being used because it gives a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar, but I hope to migrate to a better syntax soon.&lt;/p&gt;

&lt;p&gt;In this piece of code, you can also see how the parsed data is collected: parsing a &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt; will give us a list of booleans. You can also see that the parsing rules essentially dictate the type of their values (this isn’t enforced: you can put arbitrary code on the right hand side. But you will get type errors after the parsing step if you don’t assign your types consistently). If you were wondering why the nonterminal was called &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt;, here is the reason:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$binnat$_bindigit__binnat'_ :=
    &amp;lt;cons Bool&amp;gt; : Π _ : Bool Π _ : [List Bool] [List Bool].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat&lt;/code&gt; should at least contain one digit, so we added an intermediate symbol to ensure this. The final parsing rule is this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$term$=nu=_binnat_ :=
    λ bs : [List Bool] [[quote$square quoteBoolListToNat] [quoteListBool bs]]
    : Π _ : [List Bool] init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So, we can parse a &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt;, by parsing &lt;code class=&quot;highlighter-rouge&quot;&gt;=nu=&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat&lt;/code&gt; afterwards. &lt;code class=&quot;highlighter-rouge&quot;&gt;=nu=&lt;/code&gt; is an escape code for the greek character ν. If you are wondering how to write parsing rules that use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$, _&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; characters, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;=dollar=, =underscore=&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;=equals=&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;The reason why we prefix a number with this character is because meta-cedille currently has support for de-Bruijn indices, which are indicated by unprefixed numbers. This will probably be changed in some form later, but for now, we have to put up with another prefix. The more interesting part in this definition is the part to the right of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; sign. First, note that the type shows us that this should be a function that takes a list of booleans and returns a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$term&lt;/code&gt;. This is just the type of terms - it contains only a single &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; character, so this isn’t used as a parsing rule. It was just convenient to name it like this, because all its constructors are parsing rules.&lt;/p&gt;

&lt;p&gt;The more interesting part in this rule is how it is defined. First, the function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$square&lt;/code&gt; (again, not a parsing rule) represents a term constructor that applies the second term to the first one, with square brackets. Thus, if &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; are terms, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[quote$square a] b]&lt;/code&gt; represents the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[a b]&lt;/code&gt;. The term &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteBoolListToNat&lt;/code&gt; is a reference to the function &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;[[quote$square quoteBoolListToNat] x]&lt;/code&gt; represents the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[boolListToNat x]&lt;/code&gt;. Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteListBool&lt;/code&gt; is a function that turns a list of booleans into a term by recursively writing down the constructors of that list and applying them properly. So, what this function will do at the end is take the list of bools you provided and replace it by a function application of &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt; to whatever list you provided. The implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt; is more or less standard, so I’m not going to talk about it here. &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteListBool&lt;/code&gt; is implemented as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let quoteListBool :=
    [[&amp;lt;&amp;lt;inductionList Bool&amp;gt; λ _ : [List Bool] init$term&amp;gt; quoteNilBool]
      λ b : Bool λ bs : [List Bool] λ rec : init$term
        [[quote$square [[quote$square quoteConsBool] [quoteBoolFun b]]] rec]]
    : Π _ : [List Bool] init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This needs some more explanation: &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;inductionList Bool&amp;gt; λ _ : [List Bool] init$term&amp;gt;&lt;/code&gt; is a function that takes as arguments a base case for induction and an inductive step and returns a function that turns a list of bools into a term. In case the list is the empty list we want to write &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;nil Bool&amp;gt;&lt;/code&gt;, which is what the term &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteNilBool&lt;/code&gt; does. In the inductive step the list consists of a first element and a rest, bound as &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt; respectively. We also get a term &lt;code class=&quot;highlighter-rouge&quot;&gt;rec&lt;/code&gt;, which is essentially the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[quoteListBool bs]&lt;/code&gt; (but we cannot write this here: we cannot refer to a name in its own definition). We want to write &lt;code class=&quot;highlighter-rouge&quot;&gt;[[&amp;lt;cons Bool&amp;gt; b] bs]&lt;/code&gt; here, which is precisely what the term after the lambdas does.&lt;/p&gt;

&lt;p&gt;If you are wondering why I used this function and a quoted list of bools instead of just writing &lt;code class=&quot;highlighter-rouge&quot;&gt;[suc [suc ... [suc zero] ... ]]&lt;/code&gt;, this has been done for performance reasons. The generated code needs to be typechecked afterwards and writing it down in unary notation would give us exponential typechecking time in the length of the number, whereas this solution is linear. The current environment meta-cedille runs in is already incredibly slow, and having the number 1000 need 10 minutes of typechecking is just bad.&lt;/p&gt;

&lt;p&gt;After all these definitions are finished, we can apply them:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;seteval eval init stmt.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second argument to &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; tells the environment to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; prefix, which then adds our new parsing rules to the already existing ones. The third argument specifies the initial nonterminal symbol to be used by the grammar (which is something we didn’t interact with so far - we could add a new top-level statement to the language by adding a parsing rule for &lt;code class=&quot;highlighter-rouge&quot;&gt;stmt&lt;/code&gt;). The first argument specifies the evaluator, which is used to execute the parsed data and potentially modify the environment. This is just a regular function with a special result type that can be defined by the user. I will write about these in future posts.&lt;/p&gt;

&lt;p&gt;You can find the full source code &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/NatSyntax.mced&quot;&gt;here&lt;/a&gt;, but to run it, you will need to import some other files beforehand (there is no module system yet and redundant imports will throw errors and abort execution, as of now). You can have a look at &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/NatSyntaxTest.mced&quot;&gt;this file&lt;/a&gt; which imports all the necessary files.&lt;/p&gt;</content><author><name></name></author><summary type="html">This is the first in a series of posts where I am going to explain how to use the metaprogramming features of meta-cedille. Before we start discussing any specifics, I want to give a little background on the system. Meta-cedille is of course based on cedille, a minimalistic, dependently typed programming language without a datatype system. I won’t explain why cedille is an interesting theory here, but you can for example read this post by Victor Maia, or have a look at the cedille documentation. The main reason why cedille was chosen as a host language for this metaprogramming system was because of its simple implementation and consistency proof, but this is not its only advantage over other type theories.</summary></entry></feed>