<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-02-19T17:12:56+01:00</updated><id>/feed.xml</id><title type="html">Meta-cedille blog</title><subtitle>A blog about metaprogramming and dependent type theory.</subtitle><entry><title type="html">Agda vs. Coq vs. Idris</title><link href="/dependent-types/2020/02/18/agda-vs-coq-vs-idris.html" rel="alternate" type="text/html" title="Agda vs. Coq vs. Idris" /><published>2020-02-18T00:00:00+01:00</published><updated>2020-02-18T00:00:00+01:00</updated><id>/dependent-types/2020/02/18/agda-vs-coq-vs-idris</id><content type="html" xml:base="/dependent-types/2020/02/18/agda-vs-coq-vs-idris.html">&lt;p&gt;I haven’t written anything here in a while, which is mostly due to my paper about syntactic metaprogramming. It is close to being finished, but the remaining edits terrify me right now, so I thought I’d write my thoughts about this topic in hope that it will be useful to someone.&lt;/p&gt;

&lt;p&gt;Let me prefix this by a couple of words about my experience and why I didn’t include Lean and Idris2. At the time of writing, I have roughly equal experience with the three languages named in the title. I have written Meta-Cedille in Agda, used Coq to do verification of Haskell blockchain code and Idris at Statebox for various things. The reason I don’t want talk much about Lean and Idris2 here is that I don’t have much experience with both of them, and Idris2 is unfinished. What I will say is that from what I’ve seen, Lean does compete much more with Coq than with Agda and Idris, so if you would choose one of those after reading this, you are probably fine. If you would choose Coq, then I’d advise to seriously consider Lean as well (however, don’t choose Lean simply because it supports quotients. This claim is somewhat disingenuous and all the other languages here support quotients in the same way that Lean does. See for example &lt;a href=&quot;https://github.com/coq/coq/issues/10871&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Let’s start off with a short few comparisons before going into more in-depth view.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Programming language features
    &lt;ul&gt;
      &lt;li&gt;Agda: Haskell-like syntax, very powerful mixfix notation, compiles to Haskell or JS with a very nice FFI&lt;/li&gt;
      &lt;li&gt;Coq: Ocaml-like synax, recursive notation, exports to a large variety of languages&lt;/li&gt;
      &lt;li&gt;Idris: Haskell-like syntax, C and JS FFI
They all support type classes (sometimes under a different name) and in general everything that you might expect from Haskell-like languages with some changes in syntax. So if you’re used to writing Haskell code, it should be rather quick to get started in any of these, with a few caveats. First, Coq does not natively support IO. There are external tools like &lt;a href=&quot;http://coq.io/&quot;&gt;coq-io&lt;/a&gt; that you can use, but I haven’t tried them so I can’t say much about it. Agda and Idris both have an IO monad built-in. Agda’s implementation is missing some functions that you would expect from Haskell, but the FFI gives you easy access to every Haskell function you want. 
There is also the issue of termination checking. Because non-terminating functions allow you to produce a member of the empty type (which proves a false statement), all functions in all of these languages have to be terminating by default. This is enforced by a termination checker, which only finds ‘obviously’ terminating functions. In my experience maybe one in ten functions or so are not of this type. You then have to prove that your function terminates (if it does) or enable non-termination. There are also similar issues with datatype definitions and universe consistency that you might want to disable sometimes. The most recent version of Coq allows you to disable all of these checks globally (for a file). In Agda and Idris, you instead tag single functions and types to skip these checks. This is much nicer, as when you run into an infinite loop, you can easily search for functions that might be responsible. In Agda, you even have different pragmas for terminating and non-terminating functions.
I also want to mention here how well the languages handle resolution of implicit arguments, as this may clutter the code quite a bit if not working properly. This is of course not a big deal in Haskell because of the Hindley-Milner algorithm. In a dependently typed setting, this algorithm doesn’t work, and there is no algorithm that always works, so we have to rely on heuristics to some extent. Long story short, Agda and Coq have very good algorithms, where I don’t think I have seen a case where the argument they didn’t figure out was very easy and obvious. Idris’s algorithm for figuring out implicits seems to be slow and fails much more often. The failures also seem sort of random to me, whereas in Agda and Coq you get an intuition about when it might fail after using it for a while.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Proof assistant features
    &lt;ul&gt;
      &lt;li&gt;Agda: Good metaprogramming&lt;/li&gt;
      &lt;li&gt;Coq: Provides large amount of tactics and a large proof library&lt;/li&gt;
      &lt;li&gt;Idris: Reasonable metaprogramming, does not emphasize proving
Idris doesn’t really want to compete in this space, so don’t use it for that if you don’t have to. A big issue with Idris is that because of its weak handling of implicits, even if you write a nice tactic that solves something for you, you often have to provide it with a bunch of additional arguments. This seems to be the only major difference between Agda and Idris in the tactic space, but it the fact that Agda is much faster and more convenient because of its better handling of implicits make it the unconditional winner of the two in terms of a proof assistant. Agda and Coq are much more difficult to compare, but generally Coq proofs can be much shorter, while Agda proofs are often more readable. Also, it is sometimes a lot easier to write the same function in Agda than in Coq, which sometimes translates to an easier proof in Agda. This is especially the case when you deal with many instances of dependent pattern matching. Coq has the &lt;a href=&quot;https://github.com/mattam82/Coq-Equations&quot;&gt;Equations&lt;/a&gt; plugin that helps with that, but then you have to learn how to use it in addition to Coq. If you really want to focus on proofs though, the extra effort might be worth it.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Libraries
    &lt;ul&gt;
      &lt;li&gt;Agda: A few libraries exist&lt;/li&gt;
      &lt;li&gt;Coq: Has the most out of the three&lt;/li&gt;
      &lt;li&gt;Idris: Less than Coq, more than Agda
As expected, Coq libraries are mostly about proofs and Idris libraries are mostly about programming. Agda has a little bit of both, but this is definitely its weak point. It does however have the advantage that its Haskell FFI is very good and easy to use, so you can use any Haskell library in Agda, or use Agda to write a Haskell library.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tooling
    &lt;ul&gt;
      &lt;li&gt;Agda: Great emacs mode&lt;/li&gt;
      &lt;li&gt;Coq: CoqIDE and great emacs mode&lt;/li&gt;
      &lt;li&gt;Idris: Meh
If you aren’t an Emacs user, my recommendation is to bite the bullet and install it just for those languages. Install evil if you like vim and learn the few keybindings for the mode you’re using (search, etc). If you really hate Emacs, choose an editor that has a similarly powerful mode and use that, but be careful not to choose something that only gives you syntax highlighting. If your favorite editor does only support syntax highlighting for the language of your choice then pick something else. If these constraints mean that you have to learn vim, do that or reconsider your constraints. I want to further stress this point, but at this point I don’t know how.
Anyways, this is especially true for Agda, which has such powerful features that I don’t think any other programming environment can really compete with it. It does allow you to put holes in your code and then gives you the ability to write terms in the holes. You can then view the type of the hole, of all bound variables and of the expression in the hole (which can contain new holes) at the same time. It also supports case-splitting and some nice search features. Coq gives you a similarly powerful interaction in proofs (using tactics), but when writing functions you are on your own. The Emacs mode does have a feature similar to case-splitting, but it’s not quite as nice as Agda’s. Idris tries to do many of the same things that Agda does, and supports more editors, but its editor interaction software has a space leak, so in addition to Idris being slow, the integration crashes every 5th time or so you want to typecheck something, and case-splitting doesn’t seem to work reliably. You also cannot put terms in holes to view their types in the context. Thus, I’ve seen people use the Idris repl and just use syntax highlighting in the editor, which is still slow and much less powerful.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So for a conclusion, if you’ve read everything above, you should clearly see my preference of Agda over Idris in almost every scenario. If you haven’t used either, but you think you need Idris for its C FFI, I think you should start with Agda, see if you can wrap the Haskell C FFI into something that you use from Agda (the answer is probably yes), and only if this fails use Idris. If you choose Idris, be prepared to wait a lot for code to compile and things to randomly not work. There are a few more things that I haven’t said about their comparison, but those wouldn’t help the case for Idris. The question Idris vs. Coq is very easy: you know already which one you want to choose by looking at the type of your project. This leaves Coq vs. Agda. This is in my opinion the most difficult of the three, if you care about proofs (otherwise, choose Agda if you don’t need to compile to Ocaml or something special like that). Generally, I would say that if you expect to have complex code, use Agda, except if you expect to have a very large amount of proofs.&lt;/p&gt;

&lt;p&gt;As a final note, I want to redeem Idris a little bit. Even though I was very hard on it, I think the goal of having a dependently typed language that focuses on programming is a very fine one. It seems to me that because of the development of Idris2, many of the issues of Idris have been ignored for quite some time, which is how it ended up like this. I really hope that Idris2 fixes the issues mentioned here and I’m excited for its linear types. This does not change my recommendation however: if you want to switch to Idris2 later, you should use Agda and try to avoid using anything that cannot easily be translated to Idris (like Unicode and mixfix syntax). Converting source code between the two isn’t that difficult, and you save yourself a lot of headaches.&lt;/p&gt;

&lt;p&gt;TL;DR: If you care about proofs much more than about code, use Coq. Use Idris if you have a very good reason to use Idris specifically. Otherwise, use Agda.&lt;/p&gt;</content><author><name></name></author><summary type="html">I haven’t written anything here in a while, which is mostly due to my paper about syntactic metaprogramming. It is close to being finished, but the remaining edits terrify me right now, so I thought I’d write my thoughts about this topic in hope that it will be useful to someone.</summary></entry><entry><title type="html">Syntactic metaprogramming II</title><link href="/meta-cedille/2019/07/12/syntactic-metaprogramming-ii.html" rel="alternate" type="text/html" title="Syntactic metaprogramming II" /><published>2019-07-12T00:00:00+02:00</published><updated>2019-07-12T00:00:00+02:00</updated><id>/meta-cedille/2019/07/12/syntactic-metaprogramming-ii</id><content type="html" xml:base="/meta-cedille/2019/07/12/syntactic-metaprogramming-ii.html">&lt;p&gt;This is the second in a series of posts where I am going to explain how to use the metaprogramming features of &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille&quot;&gt;meta-cedille&lt;/a&gt;. If you haven’t read the &lt;a href=&quot;https://whatisrt.github.io/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html&quot;&gt;previous post&lt;/a&gt; this post might not make much sense.&lt;/p&gt;

&lt;p&gt;This time, I’ll be talking about a better function definition syntax, strings and parsing unrestricted grammars. The function definition syntax is an ML-like syntax. Let me give an example of what syntax we want to end up with:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b-let identity [X : *] (x : X) : X := x.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The main advantage of this notation is that we can get a type annotated definition without having to repeat types. The above example will de-sugar to:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let identity := Λ X : * λ x : X x : ∀ X : * Π x : X X.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So let’s discuss quickly how this works. After parsing the syntax, we will have access to a list of parameters (a parameter is a triple consisting of a flag deciding whether the parameter is supposed to be erased or not, a name and a type) and a type, in a addition to the name and the term representing the body. The list of parameters will then be converted to a stack of lambdas and a stack pis/foralls, which will be prepended to the body and the type respectively. So let’s implement it.&lt;/p&gt;

&lt;p&gt;First, I’ll use a better syntax for function application for better readability. It is implemented &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/BetterApp.mced&quot;&gt;here&lt;/a&gt;, and the syntax is &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[f x1 ... xn]&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;?xk&lt;/code&gt; refers to an erased application. In the original source this syntax isn’t used because the file that introduces it actually uses the better let definition, but we can do it here.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$param$_name__space_=colon=_space__term_ :=
  λ n : init$name λ _ : init$space λ _ : init$space λ t : init$term
    γ[mkPreParam n t].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the rule that parses the interior of parentheses, which should be quite straightforward. &lt;code class=&quot;highlighter-rouge&quot;&gt;mkPreParam&lt;/code&gt; is the constructor for a parameter without the information whether it is erased.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$params := [List Param].
let init$params$=lparen=_param_=rparen=_space__params_ :=
  λ p : PreParam λ _ : init$space γ[cons ?Param γ[mkParam false p]].
let init$params$=lsquare=_param_=rsquare=_space__params_ :=
  λ p : PreParam λ _ : init$space γ[cons ?Param γ[mkParam true p]].
let init$params$ := &amp;lt;nil Param&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These rules are for parsing a list of parameters. This should be straightforward as well: &lt;code class=&quot;highlighter-rouge&quot;&gt;mkParam&lt;/code&gt; is the constructor for a full parameter and in case we parsed it with surrounding parentheses, we pass &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;mkParam&lt;/code&gt; for an unerased parameter, and &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; for surrounding square brackets. To turn this list of parameters into the corresponding lambda abstractions, we use the following functions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let paramToLambda := λ t : init$term λ p : Param
  γ[γ[ifthenelse ?(Π _ : init$name Π _ : init$term Π _ : init$term init$term)
      [paramErased p]
      quote$Lambda
      quote$lambda]
    [paramName p] [paramType p] t]
  : Π _ : init$term Π _ : Param init$term.

let foldWithLambdas :=
  γ[foldl ?Param ?init$term paramToLambda]
  : Π _ : init$params Π _ : init$term init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$lambda&lt;/code&gt; (and all other such abstractions) is &lt;code class=&quot;highlighter-rouge&quot;&gt;Π _ : init$name Π _ : init$term Π _ : init$term init$term&lt;/code&gt;. After filling in a parameter, the type would be &lt;code class=&quot;highlighter-rouge&quot;&gt;Π _ : init$term init$term&lt;/code&gt;, so we want a function &lt;code class=&quot;highlighter-rouge&quot;&gt;Π _ : Param Π _ : init$term init$term&lt;/code&gt;. So this is what &lt;code class=&quot;highlighter-rouge&quot;&gt;paramToLambda&lt;/code&gt; does, except that the order of arguments is swapped. &lt;code class=&quot;highlighter-rouge&quot;&gt;paramErased&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;paramName&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;paramType&lt;/code&gt; are the three projections of the parameter, so &lt;code class=&quot;highlighter-rouge&quot;&gt;paramToLambda&lt;/code&gt; applies &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$lambda&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$Lambda&lt;/code&gt; (depending on the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;[paramErased p]&lt;/code&gt;) to &lt;code class=&quot;highlighter-rouge&quot;&gt;[paramName p]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;[paramType p]&lt;/code&gt;. Then, &lt;code class=&quot;highlighter-rouge&quot;&gt;foldWithLambdas&lt;/code&gt; applies this function recursively to the list of parameters. The function &lt;code class=&quot;highlighter-rouge&quot;&gt;foldWithPi&lt;/code&gt; is defined exactly the same, except that it uses &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$forall&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$Pi&lt;/code&gt;. Finally, the last parsing rule is defined as (sorry for the long name):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$stmt$b=minus=let_space__name__space__params_=colon=_space__term__space_=colon==equal=_space'__term_=dot= :=
  λ _ : init$space λ n : init$name λ _ : init$space
  λ params : init$params λ _ : init$space λ type : init$term
  λ _ : init$space λ _ : init$space' λ term : init$term
    γ[quote$annotatedLet n
      γ[foldWithLambdas params term]
      γ[foldWithPi params type]].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that this is a parsing rule for &lt;code class=&quot;highlighter-rouge&quot;&gt;stmt&lt;/code&gt;, so this is an example of how to define a new top-level statement. The function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$annotatedLet&lt;/code&gt; takes three arguments, &lt;code class=&quot;highlighter-rouge&quot;&gt;n, t&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;t'&lt;/code&gt;, and returns the quoted statement &lt;code class=&quot;highlighter-rouge&quot;&gt;let n := t : t'.&lt;/code&gt;. After setting the evaluator, we can run the above example and see it in action. It would of course be nice to improve this syntax a little bit, by allowing to bind multiple names to a type in one go (as in &lt;code class=&quot;highlighter-rouge&quot;&gt;(a b : T)&lt;/code&gt;). PR’s for this are welcome.&lt;/p&gt;

&lt;p&gt;Let’s continue with strings. Strings are of course encased in double quotes:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$term$=doublequote=_newstring_=doublequote= :=
  quote$String : Π _ : init$string init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We will get to the function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$String&lt;/code&gt; later. The interior of the double quotes is either empty or a character followed by the same nonterminal:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$newstring$ := init$string$nil : init$string.
let init$newstring$_stringchar__newstring_ :=
  init$string$cons : Π _ : init$char Π _ : init$string init$string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So what remains is to parse an (almost) arbitrary single character, which is done by the following syntax:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$stringchar$!=doublequote=! := λ c : init$char c.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The exclamation points encase a list of rules that match a single character, and negate these rules. After parsing the character, it is passed to the function. In this case, it matches every character except a double quote. So, after parsing a string, we get a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$string&lt;/code&gt;, which is essentially a list of &lt;code class=&quot;highlighter-rouge&quot;&gt;init$char&lt;/code&gt;’s, and we have to transform into a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$term&lt;/code&gt;, which is where the above mentioned &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$String&lt;/code&gt; function comes into play. It is defined as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b-let quote$String (s : init$string) : init$term :=
  γ[s ?init$term
      λ c : init$char λ rec : init$term
        γ[quote$square γ[quote$square quote$stringCons [quote$char c]] rec]
      quote$stringNil].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$string&lt;/code&gt; is defined with a Church encoding, so their elements are functions that pattern match on themselves. This can be seen in the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[s init$term]&lt;/code&gt;, which, after applying some syntactic sugar is:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(init$char -&amp;gt; init$term -&amp;gt; init$term) -&amp;gt; init$term -&amp;gt; init$term
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This means, if &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; is the empty string, &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[s ?init$term f n]&lt;/code&gt; evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, and if &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;s'&lt;/code&gt;, it evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[f c γ[s' ?init$term f n]]&lt;/code&gt;. Thus, in the case of &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$String&lt;/code&gt;, if we give the empty string to it, it evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$stringNil&lt;/code&gt; and if it is of the form &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; followed by &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;, it evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;γ[quote$square γ[quote$square quote$stringCons [quote$char c]] [quote$String s]]&lt;/code&gt; which represents &lt;code class=&quot;highlighter-rouge&quot;&gt;[[stringCons c] s]&lt;/code&gt;. The definitions of &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$stringNil&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$stringCons&lt;/code&gt; are quite tedious and not repeated here.&lt;/p&gt;

&lt;p&gt;Note that this definition for a string syntax does not feature an escaping mechanism to let the double quote be typed within a string. This has been done mostly for the simplicity of the implementation and is left as an exercise to the reader (PR’s welcome). To parse everything except for a double quote and a backslash character, use &lt;code class=&quot;highlighter-rouge&quot;&gt;!=doublequote=&amp;amp;=backslash=!&lt;/code&gt;. A syntax for a single character would also be nice (parsing single quotes is done with just a &lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt; character instead of the escape mechanism).&lt;/p&gt;

&lt;p&gt;So now it should be somewhat clear how to define new notations that extend existing syntax. Defining a syntax for lists is not too difficult (see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/ListNotation.mced&quot;&gt;here&lt;/a&gt;), while defining a notation for inductive datatypes is probably challenging but given a good understanding of cedille it should still be mostly straightforward.&lt;/p&gt;

&lt;p&gt;For the remainder of this post, I want to discuss how to modify the evaluator of the language which is a very powerful feature that can be used to run arbitrary code after the parsing step.&lt;/p&gt;

&lt;p&gt;First, I want to give a brief introduction into the idea of the evaluator. In the previous examples, the result of parsing always had to result in something that is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt;, which is essentially a built-in type. One of the goals of this system was that everything should be modifiable by the user, so this type should not be fixed. To do this, we should be able to replace it with another type, say &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, such that elements of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; can be turned into executions of the systems. This is done with the meta monad, denoted by &lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;, which is a monad that can run executions in the environment. It has the monadic operations &lt;code class=&quot;highlighter-rouge&quot;&gt;ε&lt;/code&gt; (return/pure) and &lt;code class=&quot;highlighter-rouge&quot;&gt;μ&lt;/code&gt; (bind) as well as an operation &lt;code class=&quot;highlighter-rouge&quot;&gt;ξ&lt;/code&gt; that executes statements (of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt;) and returns something of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$metaResult&lt;/code&gt; (which is a type that captures errors and other things that the executions of statements might return), so if &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ξ t&lt;/code&gt; is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;ω init$metaResult&lt;/code&gt;. So, a function &lt;code class=&quot;highlighter-rouge&quot;&gt;f : A -&amp;gt; ω B&lt;/code&gt; is a function that can execute statements based on its input and return some value of type &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, and such a function can be registered as the evaluator with the &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; statement. Then, if the parsing step returns some term &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; of type &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, the environment will execute the value &lt;code class=&quot;highlighter-rouge&quot;&gt;[f t]&lt;/code&gt;. Note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; statement does not in any way change any previous definition. It just changes the evaluator that is used to evaluate statements. It is not possible to use the pointer to the current evaluator in a definition.&lt;/p&gt;

&lt;p&gt;The function that has been used as the evaluator up to this point is defined as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; let eval := λ s : init$stmt ξ s.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To show off what is possible by changing the evaluator, I will demonstrate how to work around the limitations of the parser, to parse a language that is not context-free. This is just a toy example, but it generalizes to parsing arbitrary languages. The language we want to parse is the language of all strings consisting of the letters &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;, such that all letters appear equally often. This language is known to be context-sensitive, so in particular not a &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar that the parser can handle. To do this, we use a variation of the parsing rules for strings:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let csgdemo$char$a := quote$a : init$char.
let csgdemo$char$b := quote$b : init$char.
let csgdemo$char$c := quote$c : init$char.

let csgdemo$str := [List init$char].
let csgdemo$str$_char__str_ := &amp;lt;cons init$char&amp;gt;.
let csgdemo$str$ := &amp;lt;nil init$char&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; is a nonterminal that parses only strings of the letters &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; and returns that data as a string. Next, we define the evaluator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b-let csgdemoeval (l : [List init$char]) : ω Nat :=
  γ[ifthenelse ?(ω Nat) [abcEqual l]
    ε γ[countOccurencesChar quote$a l]
    μ [eval triggerError] λ _ : init$metaResult ε zero].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Just to make it clear how &lt;code class=&quot;highlighter-rouge&quot;&gt;ε&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;μ&lt;/code&gt; work, in a Haskell-like syntax this would read:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;csgdemoeval l =
  if abcEqual l
    then return (countOccurencesChar quote$a l)
    else (eval triggerError) &amp;gt;&amp;gt; return zero
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function &lt;code class=&quot;highlighter-rouge&quot;&gt;abcEqual&lt;/code&gt; takes a string and returns &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; iff the characters &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; appear equally as often. &lt;code class=&quot;highlighter-rouge&quot;&gt;countOccurencesChar&lt;/code&gt; takes a character and a string, and returns how often that character appears in that string. &lt;code class=&quot;highlighter-rouge&quot;&gt;triggerError&lt;/code&gt; is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;init$stmt&lt;/code&gt; and always triggers an error when executed (it represents &lt;code class=&quot;highlighter-rouge&quot;&gt;let dummy := dummy.&lt;/code&gt;, which will either complain that the name &lt;code class=&quot;highlighter-rouge&quot;&gt;dummy&lt;/code&gt; is undefined, or that the name &lt;code class=&quot;highlighter-rouge&quot;&gt;dummy&lt;/code&gt; is defined). So, &lt;code class=&quot;highlighter-rouge&quot;&gt;csgdemoeval&lt;/code&gt; will take the string, and if it has an equal count of the letters it will do nothing and return how often each letter appeared. Otherwise, it will trigger an error and return the number &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; afterwards. Finally, we set the evaluator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;seteval csgdemoeval csgdemo str.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This uses &lt;code class=&quot;highlighter-rouge&quot;&gt;csgdemoeval&lt;/code&gt; as the evaluator, &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; as the starting nonterminal and &lt;code class=&quot;highlighter-rouge&quot;&gt;csgdemo&lt;/code&gt; as the namespace.&lt;/p&gt;

&lt;p&gt;This is a very simple example of course, but it shows that it is possible to run arbitrary code to accept or reject parse results. This means that one could write a parser library that can handle stronger grammars than the built-in parser and use that library to write parsing rules. At the same time, this demonstrates how previous definitions can be hidden: after the &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; statement, there is no way to execute another &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; command, so it is impossible to go back.&lt;/p&gt;</content><author><name></name></author><summary type="html">This is the second in a series of posts where I am going to explain how to use the metaprogramming features of meta-cedille. If you haven’t read the previous post this post might not make much sense.</summary></entry><entry><title type="html">Syntactic metaprogramming I</title><link href="/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html" rel="alternate" type="text/html" title="Syntactic metaprogramming I" /><published>2019-06-25T00:00:00+02:00</published><updated>2019-06-25T00:00:00+02:00</updated><id>/meta-cedille/2019/06/25/syntactic-metaprogramming-i</id><content type="html" xml:base="/meta-cedille/2019/06/25/syntactic-metaprogramming-i.html">&lt;p&gt;This is the first in a series of posts where I am going to explain how to use the metaprogramming features of &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille&quot;&gt;meta-cedille&lt;/a&gt;. Before we start discussing any specifics, I want to give a little background on the system. Meta-cedille is of course based on &lt;a href=&quot;https://github.com/cedille/cedille&quot;&gt;cedille&lt;/a&gt;, a minimalistic, dependently typed programming language without a datatype system. I won’t explain why cedille is an interesting theory here, but you can for example read this &lt;a href=&quot;https://medium.com/@maiavictor/towards-a-simple-theorem-prover-5005a1e66a6f&quot;&gt;post&lt;/a&gt; by Victor Maia, or have a look at the &lt;a href=&quot;https://cedille.github.io/docs/about.html#about&quot;&gt;cedille documentation&lt;/a&gt;. The main reason why cedille was chosen as a host language for this metaprogramming system was because of its simple implementation and consistency proof, but this is not its only advantage over other type theories.&lt;/p&gt;

&lt;p&gt;Meta-cedille is an extension of cedille (technically, &lt;a href=&quot;https://github.com/astump/cedille-core-spec/blob/master/spec.pdf&quot;&gt;cedille-core&lt;/a&gt;, implemented &lt;a href=&quot;https://github.com/cedille/cedille/tree/master/core&quot;&gt;here&lt;/a&gt;), that adds full syntactic metaprogramming without breaking the consistency of the underlying type theory. This means that not only terms or other code can be read and written within the language itself, but also the syntax of the language can be fully modified by the programmer. A user of the language can specify their own &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar (a special type of context-free grammar, with the restriction that any non-terminal can uniquely be assigned a parsing rule by just reading one character), that is to be used for parsing. This feature seems to have lots of potential as a substitute for built-in features, as well as for enabling features that other languages miss. For a somewhat complete list of what I believe to be possible, see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Things-(potentially)-enabled-by-this-kind-of-metaprogramming&quot;&gt;here&lt;/a&gt;. In particular, it seems possible to implement a syntactic sugar for inductive datatypes, which is something that Victor Maia talks about in the above mentioned post. His issue with cedille-core is that defining an inductive datatype requires a lot of boilerplate code, making it difficult to read and write. Further, if a syntactic sugar for inductive datatypes was added, it would either be part of the language implementation, making it more complicated (and adding potential for breaking something), or be something that would be expanded to regular cedille-core code before distribution, making it difficult to read. With meta-cedille, a third option seems possible: adding the syntactic sugar with metaprogramming, combining the advantages of both previously mentioned approaches.&lt;/p&gt;

&lt;p&gt;In this first entry, we will talk about how to add a notation for natural numbers to the language. Having the ability to do this was one of the initial design goals of the language. In fact, I found it always annoying that languages like Coq or Agda didn’t have a built-in data type for natural numbers, but that they had a syntax for writing their elements built-in. Thus, the &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Terms&quot;&gt;initial syntax&lt;/a&gt; of the language consists just of the terms of cedille-core, plus some necessary extensions for metaprogramming. This syntax was built with a goal of a simple implementation, so it is very bare-bones and sometimes hard to read. But the whole point of the language is that this doesn’t matter, as everything can be changed.&lt;/p&gt;

&lt;p&gt;This will mostly be an introduction by example. If you want a full explanation of how to modify the grammar of the language, see &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/wiki/Grammar&quot;&gt;here&lt;/a&gt;. You should have some familiarity with how parsing with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free grammar&lt;/a&gt; works.&lt;/p&gt;

&lt;p&gt;Let’s get started with the parsing rules. For simplicity, we’ll only do notation in base 2, but this will of course easily generalize:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$bindigit$0 := f : Bool.
let init$bindigit$1 := t : Bool.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Note that these are definitions of values of type &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt;. These two lines just define alternative names for the two inhabitants of the type. The type annotation on the right is always optional, but it gives a good additional safety check that we really have defined the right thing (it can also be used to replace an inferred type by a nicer, equivalent type). The important part happens to the left of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; sign: the names of values &lt;em&gt;may&lt;/em&gt; be used for parsing rules. Parsing rules consist of three parts, separated by &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; characters: first, a &lt;em&gt;prefix&lt;/em&gt; (or namespace, whatever you prefer), second a &lt;em&gt;nonterminal symbol&lt;/em&gt;, and third a &lt;em&gt;replacement&lt;/em&gt;. The prefix is later passed to a special command that applies the changes to the grammar, and all rules with that prefix will be considered. As we want to extend the previous grammar, we have to use the prefix &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;. The nonterminal and replacements are fairly simple: we introduce two rules for a nonterminal &lt;code class=&quot;highlighter-rouge&quot;&gt;bindigit&lt;/code&gt; (that didn’t exist before), and it can be parsed either as &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; or as &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. Depending on which digit was parsed, this will then either return the term &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;. Next:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$binnat'$_bindigit__binnat'_ :=
    &amp;lt;cons Bool&amp;gt; : Π _ : Bool Π _ : [List Bool] [List Bool].
    -- with better syntax, this would be Bool -&amp;gt; List Bool -&amp;gt; List Bool
let init$binnat'$ := &amp;lt;nil Bool&amp;gt; : [List Bool].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here, we’re defining a nonterminal &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt;, that can either be parsed by first parsing a &lt;code class=&quot;highlighter-rouge&quot;&gt;bindigit&lt;/code&gt; and then another &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt; (i.e. a digit and then possibly some more digits), or by parsing an empty string. Note that the square brackets denote the application of a term to a term, and the angle brackets denote erased application of terms (so if you would write &lt;code class=&quot;highlighter-rouge&quot;&gt;f x y&lt;/code&gt; in Haskell, you would have to write &lt;code class=&quot;highlighter-rouge&quot;&gt;[[f x] y]&lt;/code&gt; here). If you don’t know cedille, you can just regard the two forms of application as the same thing for now. This syntax is currently being used because it gives a simple &lt;code class=&quot;highlighter-rouge&quot;&gt;LL1&lt;/code&gt; grammar, but I hope to migrate to a better syntax soon.&lt;/p&gt;

&lt;p&gt;In this piece of code, you can also see how the parsed data is collected: parsing a &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt; will give us a list of booleans. You can also see that the parsing rules essentially dictate the type of their values (this isn’t enforced: you can put arbitrary code on the right hand side. But you will get type errors after the parsing step if you don’t assign your types consistently). If you were wondering why the nonterminal was called &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat'&lt;/code&gt;, here is the reason:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$binnat$_bindigit__binnat'_ :=
    &amp;lt;cons Bool&amp;gt; : Π _ : Bool Π _ : [List Bool] [List Bool].
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat&lt;/code&gt; should at least contain one digit, so we added an intermediate symbol to ensure this. The final parsing rule is this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let init$term$=nu=_binnat_ :=
    λ bs : [List Bool] [[quote$square quoteBoolListToNat] [quoteListBool bs]]
    : Π _ : [List Bool] init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So, we can parse a &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt;, by parsing &lt;code class=&quot;highlighter-rouge&quot;&gt;=nu=&lt;/code&gt; and a &lt;code class=&quot;highlighter-rouge&quot;&gt;binnat&lt;/code&gt; afterwards. &lt;code class=&quot;highlighter-rouge&quot;&gt;=nu=&lt;/code&gt; is an escape code for the greek character ν. If you are wondering how to write parsing rules that use the &lt;code class=&quot;highlighter-rouge&quot;&gt;$, _&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; characters, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;=dollar=, =underscore=&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;=equals=&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;The reason why we prefix a number with this character is because meta-cedille currently has support for de-Bruijn indices, which are indicated by unprefixed numbers. This will probably be changed in some form later, but for now, we have to put up with another prefix. The more interesting part in this definition is the part to the right of the &lt;code class=&quot;highlighter-rouge&quot;&gt;:=&lt;/code&gt; sign. First, note that the type shows us that this should be a function that takes a list of booleans and returns a &lt;code class=&quot;highlighter-rouge&quot;&gt;init$term&lt;/code&gt;. This is just the type of terms - it contains only a single &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; character, so this isn’t used as a parsing rule. It was just convenient to name it like this, because all its constructors are parsing rules.&lt;/p&gt;

&lt;p&gt;The more interesting part in this rule is how it is defined. First, the function &lt;code class=&quot;highlighter-rouge&quot;&gt;quote$square&lt;/code&gt; (again, not a parsing rule) represents a term constructor that applies the second term to the first one, with square brackets. Thus, if &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; are terms, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[quote$square a] b]&lt;/code&gt; represents the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[a b]&lt;/code&gt;. The term &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteBoolListToNat&lt;/code&gt; is a reference to the function &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;[[quote$square quoteBoolListToNat] x]&lt;/code&gt; represents the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[boolListToNat x]&lt;/code&gt;. Finally, &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteListBool&lt;/code&gt; is a function that turns a list of booleans into a term by recursively writing down the constructors of that list and applying them properly. So, what this function will do at the end is take the list of bools you provided and replace it by a function application of &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt; to whatever list you provided. The implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;boolListToNat&lt;/code&gt; is more or less standard, so I’m not going to talk about it here. &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteListBool&lt;/code&gt; is implemented as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let quoteListBool :=
    [[&amp;lt;&amp;lt;inductionList Bool&amp;gt; λ _ : [List Bool] init$term&amp;gt; quoteNilBool]
      λ b : Bool λ bs : [List Bool] λ rec : init$term
        [[quote$square [[quote$square quoteConsBool] [quoteBoolFun b]]] rec]]
    : Π _ : [List Bool] init$term.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This needs some more explanation: &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;inductionList Bool&amp;gt; λ _ : [List Bool] init$term&amp;gt;&lt;/code&gt; is a function that takes as arguments a base case for induction and an inductive step and returns a function that turns a list of bools into a term. In case the list is the empty list we want to write &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;nil Bool&amp;gt;&lt;/code&gt;, which is what the term &lt;code class=&quot;highlighter-rouge&quot;&gt;quoteNilBool&lt;/code&gt; does. In the inductive step the list consists of a first element and a rest, bound as &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt; respectively. We also get a term &lt;code class=&quot;highlighter-rouge&quot;&gt;rec&lt;/code&gt;, which is essentially the term &lt;code class=&quot;highlighter-rouge&quot;&gt;[quoteListBool bs]&lt;/code&gt; (but we cannot write this here: we cannot refer to a name in its own definition). We want to write &lt;code class=&quot;highlighter-rouge&quot;&gt;[[&amp;lt;cons Bool&amp;gt; b] bs]&lt;/code&gt; here, which is precisely what the term after the lambdas does.&lt;/p&gt;

&lt;p&gt;If you are wondering why I used this function and a quoted list of bools instead of just writing &lt;code class=&quot;highlighter-rouge&quot;&gt;[suc [suc ... [suc zero] ... ]]&lt;/code&gt;, this has been done for performance reasons. The generated code needs to be typechecked afterwards and writing it down in unary notation would give us exponential typechecking time in the length of the number, whereas this solution is linear. The current environment meta-cedille runs in is already incredibly slow, and having the number 1000 need 10 minutes of typechecking is just bad.&lt;/p&gt;

&lt;p&gt;After all these definitions are finished, we can apply them:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;seteval eval init stmt.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second argument to &lt;code class=&quot;highlighter-rouge&quot;&gt;seteval&lt;/code&gt; tells the environment to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; prefix, which then adds our new parsing rules to the already existing ones. The third argument specifies the initial nonterminal symbol to be used by the grammar (which is something we didn’t interact with so far - we could add a new top-level statement to the language by adding a parsing rule for &lt;code class=&quot;highlighter-rouge&quot;&gt;stmt&lt;/code&gt;). The first argument specifies the evaluator, which is used to execute the parsed data and potentially modify the environment. This is just a regular function with a special result type that can be defined by the user. I will write about these in future posts.&lt;/p&gt;

&lt;p&gt;You can find the full source code &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/NatSyntax.mced&quot;&gt;here&lt;/a&gt;, but to run it, you will need to import some other files beforehand (there is no module system yet and redundant imports will throw errors and abort execution, as of now). You can have a look at &lt;a href=&quot;https://github.com/WhatisRT/meta-cedille/blob/master/test/NatSyntaxTest.mced&quot;&gt;this file&lt;/a&gt; which imports all the necessary files.&lt;/p&gt;</content><author><name></name></author><summary type="html">This is the first in a series of posts where I am going to explain how to use the metaprogramming features of meta-cedille. Before we start discussing any specifics, I want to give a little background on the system. Meta-cedille is of course based on cedille, a minimalistic, dependently typed programming language without a datatype system. I won’t explain why cedille is an interesting theory here, but you can for example read this post by Victor Maia, or have a look at the cedille documentation. The main reason why cedille was chosen as a host language for this metaprogramming system was because of its simple implementation and consistency proof, but this is not its only advantage over other type theories.</summary></entry></feed>